<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
		<link rel="stylesheet" type="text/css" href="https://threejs.org/files/main.css">
		<style>
			canvas {
				display: block;
				width: 100%;
				height: 100%;
			}

			#newWindow {
				display: block;
				position: absolute;
				bottom: 0.3em;
				left: 0.5em;
				color: #fff;
			}
		</style>

<!-- Or by plain js https://medium.com/@necsoft/three-js-101-hello-world-part-1-443207b1ebe1 -->
	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.163.0/build/three.module.js",
				"three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
			}
		}
	</script>
</head>

<body>
	<script type="module">
		import * as THREE from 'three';
		import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		// or
		//   import { OrbitControls } from 'https://unpkg.com/three@0.163.0/examples/jsm/controls/OrbitControls.js'
		
		// ------------------------------------------------
		// BASIC SETUP
		// ------------------------------------------------

		// Create an empty scene
		var scene = new THREE.Scene();
		scene.background = new THREE.Color( 0x444444 );
		
		// Create a basic perspective camera
		var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.z = 30;

		// Create a renderer with Antialiasing
		var renderer = new THREE.WebGLRenderer({ antialias: true });

		renderer.setPixelRatio( window.devicePixelRatio );

		// Configure renderer size
		renderer.setSize(window.innerWidth, window.innerHeight);

		// Append Renderer to DOM
		document.body.appendChild(renderer.domElement);
		
		
		
		
	

		const orbit = new OrbitControls( camera, renderer.domElement );
		orbit.enableZoom = true;

		const lights = [];
		lights[ 0 ] = new THREE.DirectionalLight( 0xffffff, 3 );
		lights[ 1 ] = new THREE.DirectionalLight( 0xffffff, 3 );
		lights[ 2 ] = new THREE.DirectionalLight( 0xffffff, 3 );

		lights[ 0 ].position.set( 0, 200, 0 );
		lights[ 1 ].position.set( 100, 200, 100 );
		lights[ 2 ].position.set( - 100, - 200, - 100 );

		scene.add( lights[ 0 ] );
		scene.add( lights[ 1 ] );
		scene.add( lights[ 2 ] );
	
    //   // Thread parameters
	//   	const threadHeight = 2; // Height of the triangle in mm
    //     const threadBase = 4;   // Base length of the triangle in mm
    //     const threadPitch = 1;  // M6 thread pitch in mm
    //     const threadLength = 30; // Length of the thread
    //     const turns = threadLength / threadPitch; // Number of turns

    //     // Create the shape for the triangular thread profile
    //     const shape = new THREE.Shape();

    //     // Create extrusion settings
    //     const extrudeSettings = {
    //         steps: 1,
    //         depth: threadPitch, // Depth of each thread for extrusion
    //         bevelEnabled: false
    //     };

    //     // Create the thread geometry
    //     const threadGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        
    //     // Create the thread mesh
    //     const material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
    //     const thread = new THREE.Mesh(threadGeometry, material);

    //     // Position the thread correctly
    //     thread.rotation.x = Math.PI / 2; // Rotate to lay flat

    //     // Create the spiral shape for the thread
    //     const spiralPoints = [];
    //     for (let i = 0; i <= turns * 32; i++) {
    //         const angle = (i / 32) * Math.PI * 2 * turns;
    //         const x = (threadBase / 2) * Math.cos(angle);
    //         const y = (threadBase / 2) * Math.sin(angle);
    //         const z = (i / 32) * threadPitch; // Vertical position
    //         spiralPoints.push(new THREE.Vector3(x, y, z));
    //     }

    //     // Create the spiral geometry
    //     const spiralGeometry = new THREE.BufferGeometry().setFromPoints(spiralPoints);
    //     const spiralMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    //     const spiral = new THREE.Line(spiralGeometry, spiralMaterial);
        
    //     // Add objects to the scene
    //     scene.add(thread);
    //     scene.add(spiral);















	// 	const randomPoints = [];

	// 		for ( let i = 0; i < 100; i ++ ) {

	// 			const angle = (i / 32) * Math.PI * 2 * turns;
	// 			const x = (threadBase / 2) * Math.cos(angle);
	// 			const y = (threadBase / 2) * Math.sin(angle);
	// 			const z = (i / 32) * threadPitch; // Vertical position
	// 			randomPoints.push(new THREE.Vector3(x, y, z));

	// 			//randomPoints.push( new THREE.Vector3( ( i - 4.5 ) * 50, THREE.MathUtils.randFloat( - 50, 50 ), THREE.MathUtils.randFloat( - 50, 50 ) ) );

	// 		}

	// 			const randomSpline = new THREE.CatmullRomCurve3( randomPoints );

	// 			//

	// 			const extrudeSettings2 = {
	// 				steps: 200,
	// 				bevelEnabled: false,
	// 				extrudePath: randomSpline
	// 			};


	// 			// const pts2 = [], numPts = 5;

	// 			// for ( let i = 0; i < numPts * 2; i ++ ) {

	// 			// 	const l = i % 2 == 1 ? 10 : 20;

	// 			// 	const a = i / numPts * Math.PI;
					

	// 			// 	pts2.push( new THREE.Vector2( Math.cos( a ) * l, Math.sin( a ) * l ) );

	// 			// }

	// 			const shape2 = new THREE.PlaneGeometry( 1, 1 );

	// 			const geometry2 = new THREE.ExtrudeGeometry( shape2, extrudeSettings2 );

	// 			const material2 = new THREE.MeshLambertMaterial( { color: 0xff8000, wireframe: false } );

	// 			const mesh2 = new THREE.Mesh( geometry2, material2 );

	// 			scene.add( mesh2 );

	const radius = 20;
const height = 100;
const turns = 5;
const pointsCount = 1000;

// Create a helix curve
const helixPoints = [];
for (let i = 0; i <= pointsCount; i++) {
    const angle = (i / pointsCount) * turns * Math.PI * 2; // Full turns
    const x = radius * Math.cos(angle);
    const y = height * (i / pointsCount); // Height increases linearly
    const z = radius * Math.sin(angle);
    helixPoints.push(new THREE.Vector3(x, y, z));
}

const helixSpline = new THREE.CatmullRomCurve3(helixPoints);
helixSpline.curveType = 'catmullrom';
helixSpline.closed = false; // Not a closed helix

const extrudeSettingsHelix = {
    steps: 100,
    bevelEnabled: false,
    extrudePath: helixSpline
};

// Create a circular shape for the extrusion
const ptsHelix = [];
const circlePoints = 2000; // Number of points in the circle

for (let i = 0; i < circlePoints; i++) {
    const angle = (i / circlePoints) * Math.PI * 2;
    ptsHelix.push(new THREE.Vector2(Math.cos(angle), Math.sin(angle))); // Unit circle
}

const shapeHelix = new THREE.Shape(ptsHelix);
const geometryHelix = new THREE.ExtrudeGeometry(shapeHelix, extrudeSettingsHelix);
const materialHelix = new THREE.MeshLambertMaterial({ color: 0xb00000, wireframe: false });

const meshHelix = new THREE.Mesh(geometryHelix, materialHelix);
scene.add(meshHelix);
		// // Add cube to Scene


		// Render Loop
		var render = function () {
			requestAnimationFrame(render);
			

			// group.rotation.x += 0.005;
			// group.rotation.y += 0.005;


			// Render the scene
			renderer.render(scene, camera);
		};

		render();
		
		
		
		
		

		window.addEventListener( 'resize', function () {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}, false );


		
		
		
		
		
		
		
		
		
		
		
		
	</script>
</body>

</html>
